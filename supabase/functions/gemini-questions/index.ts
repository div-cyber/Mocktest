import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
}

interface QuestionRequest {
  pdfUrl?: string
  text?: string
  section: 'engineering' | 'medical'
  difficulty: 'easy' | 'medium' | 'hard'
  questionCount: number
  subject?: string
}

interface MCQ {
  question: string
  options: string[]
  correctAnswer: number
  explanation: string
  subject: string
  difficulty: string
}

serve(async (req: Request) => {
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: corsHeaders,
    })
  }

  try {
    const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY')
    if (!GEMINI_API_KEY) {
      throw new Error('GEMINI_API_KEY not configured')
    }

    const { pdfUrl, text, section, difficulty, questionCount, subject }: QuestionRequest = await req.json()

    let content = text || ''

    // If PDF URL is provided, fetch and extract text (simplified - in production you'd use proper PDF parsing)
    if (pdfUrl) {
      try {
        const pdfResponse = await fetch(pdfUrl)
        if (pdfResponse.ok) {
          // In a real implementation, you'd use a PDF parsing library
          // For now, we'll simulate PDF content extraction
          content = `PDF content from ${pdfUrl} - This would contain the actual extracted text from the PDF document.`
        }
      } catch (error) {
        console.error('Error fetching PDF:', error)
      }
    }

    if (!content) {
      throw new Error('No content provided for question generation')
    }

    // Enhanced prompt for better question generation
    const examType = section === 'engineering' ? 'IOE entrance exam of Nepal' : 'MOE entrance exam of Nepal'
    const subjectContext = subject ? ` focusing on ${subject}` : ''
    
    const prompt = `You are an expert question setter for the ${examType}${subjectContext}. 

Based on the following content, generate exactly ${questionCount} high-quality multiple-choice questions at ${difficulty} difficulty level.

IMPORTANT REQUIREMENTS:
1. Each question must have exactly 4 options (A, B, C, D)
2. Only ONE option should be correct
3. Questions should test understanding, not just memorization
4. Include detailed explanations for correct answers
5. Vary question types (conceptual, analytical, application-based)
6. Ensure questions are relevant to ${section} entrance exam standards

Content to base questions on:
${content}

Return ONLY a valid JSON array with this exact structure:
[
  {
    "question": "Question text here",
    "options": ["Option A", "Option B", "Option C", "Option D"],
    "correctAnswer": 0,
    "explanation": "Detailed explanation of why this answer is correct",
    "subject": "${subject || 'General'}",
    "difficulty": "${difficulty}"
  }
]

Generate exactly ${questionCount} questions following this format.`

    const geminiResponse = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 8192,
          },
        }),
      }
    )

    if (!geminiResponse.ok) {
      throw new Error(`Gemini API error: ${geminiResponse.status}`)
    }

    const geminiData = await geminiResponse.json()
    const generatedText = geminiData.candidates?.[0]?.content?.parts?.[0]?.text

    if (!generatedText) {
      throw new Error('No content generated by Gemini')
    }

    // Parse the JSON response
    let questions: MCQ[]
    try {
      // Clean the response to extract JSON
      const jsonMatch = generatedText.match(/\[[\s\S]*\]/)
      if (jsonMatch) {
        questions = JSON.parse(jsonMatch[0])
      } else {
        questions = JSON.parse(generatedText)
      }
    } catch (parseError) {
      console.error('JSON parsing error:', parseError)
      // Fallback: return the raw text for debugging
      return new Response(
        JSON.stringify({ 
          error: 'Failed to parse questions', 
          rawResponse: generatedText 
        }),
        {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      )
    }

    // Validate questions structure
    const validatedQuestions = questions.filter(q => 
      q.question && 
      Array.isArray(q.options) && 
      q.options.length === 4 &&
      typeof q.correctAnswer === 'number' &&
      q.correctAnswer >= 0 && 
      q.correctAnswer < 4 &&
      q.explanation
    )

    return new Response(
      JSON.stringify({ 
        questions: validatedQuestions,
        totalGenerated: validatedQuestions.length 
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    )

  } catch (error) {
    console.error('Error:', error)
    return new Response(
      JSON.stringify({ 
        error: error.message || 'Internal server error',
        details: 'Failed to generate questions'
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    )
  }
})